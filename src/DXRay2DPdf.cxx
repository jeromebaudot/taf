/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "DXRay2DPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(DXRay2DPdf) 

//===============================================================================
DXRay2DPdf::DXRay2DPdf()
{
}
//===============================================================================  
DXRay2DPdf::DXRay2DPdf(const char *name, const char *title, 
		       RooAbsReal& _x,
		       RooAbsReal& _y,
		       RooAbsReal& _X0,
		       RooAbsReal& _sigma,
		       RooAbsReal& _beta,
		       RooAbsReal& _alpha,
		       RooAbsReal& _phi,
		       RooAbsReal& _W1,
		       RooAbsReal& _W2,
		       RooAbsReal& _W3,
		       RooAbsReal& _W4,
		       RooAbsReal& _W5,
		       RooAbsReal& _S2,
		       RooAbsReal& _S3,
		       RooAbsReal& _S4,
		       RooAbsReal& _S5) :
  RooAbsPdf(name,title), 
  x    ("x",    "x"    , this,_x),
  y    ("y",    "y"    , this,_y),
  X0   ("X0",   "X_{0}", this,_X0),
  sigma("sigma","#sigma",this,_sigma),
  beta ("beta", "#beta", this,_beta),
  alpha("alpha","#alpha",this,_alpha),
  phi  ("phi",  "#phi",  this,_phi),
  W1   ("W1",   "W_{1}", this,_W1),
  W2   ("W2",   "W_{2}", this,_W2),
  W3   ("W3",   "W_{3}", this,_W3),
  W4   ("W4",   "W_{4}", this,_W4),
  W5   ("W5",   "W_{5}", this,_W5),
  S2   ("S2",   "S_{2}", this,_S2),
  S3   ("S3",   "S_{3}", this,_S3),
  S4   ("S4",   "S_{4}", this,_S4),
  S5   ("S5",   "S_{5}", this,_S5)
{
} 
//===============================================================================
DXRay2DPdf::DXRay2DPdf(const DXRay2DPdf& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  y("y",this,other.y),
  X0("X0",this,other.X0),
  sigma("sigma",this,other.sigma),
  beta("beta",this,other.beta),
  alpha("alpha",this,other.alpha),
  phi("phi",this,other.phi),
  W1("W1",this,other.W1),
  W2("W2",this,other.W2),
  W3("W3",this,other.W3),
  W4("W4",this,other.W4),
  W5("W5",this,other.W5),
  S2("S2",this,other.S2),
  S3("S3",this,other.S3),
  S4("S4",this,other.S4),
  S5("S5",this,other.S5)
{ 
}
//===============================================================================
TObject* DXRay2DPdf::clone(const char* newname) const
{

  return new DXRay2DPdf(*this,newname);

}
//===============================================================================
DXRay2DPdf::~DXRay2DPdf()
{
}
//===============================================================================
double DXRay2DPdf::evaluate() const 
{ 

   const int Npeak(5);

   double W[Npeak];
   W[0] = W1;
   W[1] = W2;
   W[2] = W3;
   W[3] = W4;
   W[4] = W5;

   double S[Npeak];
   S[0] = 0.0;
   S[1] = S2;
   S[2] = S3;
   S[3] = S4;
   S[4] = S5;

  double ST = 0.0;
  double WT = 0.0;
  for(int i=0;i<Npeak;i++) {
    ST += S[i];
    WT += W[i];
  }

  double DeltaY  = (y.max() - y.min())/cos(phi*TMath::Pi()/180.0);
  DeltaY        += W[0]*tan(phi*TMath::Pi()/180.0);
  double AveY    = 0.5*(y.max() + y.min());

  double Sadd[Npeak];
  for(int i=0;i<Npeak;i++) {
    Sadd[i] = 0.0;
    for(int j=0;j<i+1;j++) {
      Sadd[i] += S[j];
    }
  }

  double Gamma = 0.0;
  if(Npeak > 1) {
    for(int j=0;j<Npeak;j++) {
      Gamma += W[j]*Sadd[j]/WT;
    }
  }


  double radius = 1.0e+20;
  double SaddTot = 0.0;
  for(int i=0;i<Npeak;i++) {
    SaddTot += S[i];
  }
  SaddTot += 0.5*W[Npeak-1];

  double alphaAbs = TMath::Abs(alpha);
  
  if(alpha >= -180.0 && alpha < -90.0) {
    radius = (SaddTot - Gamma)*(-cos(alpha*TMath::Pi()/180.0)) - 0.5*DeltaY*sin(alpha*TMath::Pi()/180.0);
  }
  else if(alpha >= -90.0 && alpha < 0.0) {
    radius = (0.5*W[0] + Gamma)*cos(alpha*TMath::Pi()/180.0) - 0.5*DeltaY*sin(alpha*TMath::Pi()/180.0);
  }
  else if(alpha >= 0.0 && alpha < 90.0) {
    radius = (0.5*W[0] + Gamma)*cos(alpha*TMath::Pi()/180.0) + 0.5*DeltaY*sin(alpha*TMath::Pi()/180.0);
  }
  else if(alpha >= 90.0 && alpha < 180.0) {
    radius = (SaddTot - Gamma)*(-cos(alpha*TMath::Pi()/180.0)) + 0.5*DeltaY*sin(alpha*TMath::Pi()/180.0);
  }

  double X0t   =  X0*cos(phi*TMath::Pi()/180.0) + AveY*sin(phi*TMath::Pi()/180.0);
  double AveYt = -X0*sin(phi*TMath::Pi()/180.0) + AveY*cos(phi*TMath::Pi()/180.0);

  double Xvalt =  x*cos(phi*TMath::Pi()/180.0) + y*sin(phi*TMath::Pi()/180.0);
  double Yvalt = -x*sin(phi*TMath::Pi()/180.0) + y*cos(phi*TMath::Pi()/180.0);

  double Factor1  = cos(alpha*TMath::Pi()/180.0)*(Xvalt - X0t - Gamma) + sin(alpha*TMath::Pi()/180.0)*(Yvalt - AveYt);
  Factor1        *= (beta/radius);
  Factor1        += 1.0;

  double Factor2 = (beta/radius)*sigma*sqrt(2.0/TMath::Pi())*cos(alpha*TMath::Pi()/180.0);
  
  double val1 = 0.0;
  double val2 = 0.0;
  for(int i=0;i<Npeak;i++) {
    double Xhi  = X0t + Sadd[i] + 0.5*W[i] - Xvalt;
    Xhi        /= sqrt(2.0)*sigma;
    double Xli  = X0t + Sadd[i] - 0.5*W[i] - Xvalt;
    Xli        /= sqrt(2.0)*sigma;
    
    val1 += TMath::Erfc(Xli) - TMath::Erfc(Xhi);
    val2 += TMath::Exp(-pow(Xli,2)) - TMath::Exp(-pow(Xhi,2));
  }
  val1 *= Factor1;
  val2 *= Factor2;
  
  double val = val1 + val2;
  val /= (2.0*WT*DeltaY);

  double limit = 1.0e-20;

  //val = TMath::Abs(val);

  //if(TMath::Abs(val) < limit) val = limit;
  //if(TMath::Abs(val) < limit) val = TMath::Abs(val);
  if(val < limit) val = TMath::Abs(val);
  if(val < 0.0) cout << "val = " << val << endl;

  return val;

} 
//===============================================================================


